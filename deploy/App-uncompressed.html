<!DOCTYPE html>
<html>
<head>
    <title>snapshots-per-month</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                
Ext.define('CustomApp', {
	extend: 'Rally.app.App',
	componentCls: 'app',
	// items:{ html:'<a href="https://help.rallydev.com/apps/2.0rc3/doc/">App SDK 2.0rc3 Docs</a>'},

    config: {
        defaultSettings: {
            months : "6",
            wsapiProjects : false
        }
    },

	launch: function() {

		var that = this;

        that.rallyFunctions = Ext.create("RallyFunctions",{ 
            ctx : that.getContext(),
        	keys : ['projects']
        });

		that.months = that.createMonthRanges();

		if ( that.getSetting("wsapiProjects")==true) {
			that.rallyFunctions.readRallyItems(function(error,bundle){
    	    	console.log("rallyFunctions",error,bundle);
    	    	console.log("projects",_.map(bundle.projects,function(p){
    	    		return p.get("Name");
    	    	}));
	            that.bundle = bundle;
	            that.createChart();	
        	});
		} else {
			that.createChart();	
		}
		
	},

	createMonthRanges : function() {
		var that = this;
		var date = new Date();
		var mArray = [];
		console.log("months",that.getSetting("months"));

		for(x=0; x < parseInt(that.getSetting("months")); x++) {
			var firstDay = new Date(date.getFullYear(), date.getMonth()-x, 1);
			var lastDay = new Date(date.getFullYear(), (date.getMonth()-x) + 1, 0);
			mArray.push({
				label : firstDay.getFullYear() + "-" + 
					firstDay.toLocaleString("en-us", { month: "long" }),
				first : firstDay.toISOString().substring(0,10),
				last : lastDay.toISOString().substring(0,10)
			})
		}
		mArray.reverse();
		console.log("months",mArray);
		return mArray;
	},

	createChart: function (projects) {

		var that = this;

		var configs = _.map(that.months,function(m) {
            var find = {
                "$and" : [{"_ValidFrom": {"$gte" : m.first}}, {"_ValidFrom":{"$lte" : m.last }}]
            }

            if (that.getSetting("wsapiProjects")==false) {
                find['_ProjectHierarchy'] = that.getContext().getProject().ObjectID
            } else {
                find['Project'] = { "$in" :
                    _.map( that.bundle.projects,function( p ) { 
                        return p.get("ObjectID")})
                }
            }

            console.log("find",find);

			return  {
				find : find,
				fetch: ['_ValidFrom','_TypeHierarchy'],
				hydrate: ['_TypeHierarchy']
			}
		});

		async.map( configs, that.snapshotQuery, function(err,results) {
			console.log(results);
			that.add(that.createExtChart(results));
		} );
	},

	createExtChart : function(results) {
		var that = this;

		// convert the arrays of data into a json format for jston store 
		var data = _.map(results, function(data,i) {
			return {
				month : that.months[i].label,
				count : (data)
			};
		});

		// create the store
		var chartStore = Ext.create('Ext.data.JsonStore', {
			fields: ['month','count'],
			data: data
		});

		var chart = new Ext.chart.Chart({
			width: that.getWidth(),
			height: that.getHeight(),
			animate: true,
			store: chartStore,
			// renderTo: Ext.getBody(),
			shadow: true,
			axes: [{
				type: 'Numeric',
				position: 'left',
				fields: ['count'],
				label: {
					renderer: Ext.util.Format.numberRenderer('0,0')
				},
				title: 'Count',
				grid: true,
				minimum: 0
			}, {
				type: 'Category',
				position: 'bottom',
				fields: ['month'],
				title: 'Month',
				label : {
					rotate: {
	     				degrees: 45
	    			}
	    		},
			}],
			series: [{
				type: 'column',
				axis: 'bottom',
				highlight: true,
				xField: 'month',
				yField: 'count',
				label : {
					field : 'count',
					display : 'rotate'

				}
				// tooltip: {
    //                 // trackMouse: true,
    //                 renderer: function(tip, item) {
    //                     tip.setTitle(item.get('month'));
    //                     tip.update('Count: ' + item.get('count'));
    //                 }
    //             }
			}]
		});

		return chart;

	},

	snapshotQuery : function( config, callback ) {

		Ext.create('Rally.data.lookback.SnapshotStore', {
			find : config.find,
			autoLoad : true,
			limit : 10,
			fetch : config.fetch,
			hydrate : config.hydrate,
			pageSize: 10,

			listeners : {
				scope : this,
				load: function(store, snapshots, success) {
					console.log("Loaded:"+snapshots.length," Snapshots.");
					console.log("Store",store);
					// callback(null,snapshots);
					callback(null,store.totalCount);
				}
			}
		});
		
	},

    getSettingsFields: function() {
        var me = this;

		return [ {
            name: 'months',
            xtype: 'rallytextfield',
            boxLabelAlign: 'after',
            fieldLabel: '# Months',
            margin: '0 0 15 50',
            labelStyle : "width:200px;",
            afterLabelTpl: 'The number of months to report on.'
        },{
            name: 'wsapiProjects',
            xtype: 'rallycheckboxfield',
            boxLabelAlign: 'after',
            fieldLabel: 'True to read projects using wsapi',
            margin: '0 0 15 50',
            labelStyle : "width:200px;",
            afterLabelTpl: 'otherwise will use the lbapi project scoping'
        }];
    }

});

                /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
Ext.define("RallyFunctions", function() {

    var self;

    return {
        config : {
            ctx : {},
            filter : null,
            featureFilter : null,
            keys : [],
            fns : {}
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            self.fns['scheduleStates'] = self._readStates
            self.fns['peValues']   = self._loadPreliminaryEstimateValues
            self.fns['releases']   = self._loadReleases
            self.fns['iterations'] = self._loadIterations
            self.fns['projects']   = self._loadProjects
            self.fns['projectReleases'] = self._loadProjectReleases
            self.fns['piTypes']    = self._loadPortfolioItemTypes
            return this;
        },

        readRallyItems : function(callback) {

            var fns = [self._initBundle];
            _.each(self.keys,function(key) {
                if (_.contains(_.keys(self.fns),key))
                    fns.push(self.fns[key])
            });

            Deft.Chain.pipeline(fns,self).then({
                success: function(bundle) {
                    callback( null, bundle);
                },
                failure: function(error) {
                    //oh noes!
                    console.log("Error:",error);
                    callback(error,null);
                }
            });
        },

        readProjectWorkItems : function(callback) {

            console.log('readProjectWorkItems', self.featureFilter);
            
            var fns = [
                self.readStates,
                self.readProjects,
                self.readStories
            ];

            if (self.featureFilter!==null) {
                fns = [
                    self.readStates,
                    self.readProjects,
                    self.readFeatures
                ];
            }

            Deft.Chain.pipeline(fns,self).then({
                success: function(workItems) {
                    callback( null, workItems, self.projects, self.scheduleStates);
                },
                failure: function(error) {
                    //oh noes!
                    console.log("Error:",error);
                }
            });
        },

        _initBundle :  function() {
            console.log("_initBundle");
            var deferred = Ext.create('Deft.Deferred');
            deferred.resolve({});
            return deferred.promise;
        },

        _readStates : function(bundle) {
            var that = this;
            var deferred = Ext.create('Deft.Deferred');

            Rally.data.ModelFactory.getModel({
                type: 'UserStory',
                success: function(model) {
                    model.getField('ScheduleState').getAllowedValueStore().load({
                        callback: function(records, operation, success) {
                            var scheduleStates = _.map(records,function(r){ return r.get("StringValue");});
                            deferred.resolve({scheduleStates:scheduleStates});
                        }
                    });
                }
            });
            return deferred.promise;
        },

        _loadPreliminaryEstimateValues : function(bundle) {
            var that = this;
            console.log("_loadPreliminaryEstimateValues");
            var deferred = Ext.create('Deft.Deferred');

            that._loadAStoreWithAPromise( 
                'PreliminaryEstimate',
                true,
                []).then({
                    success : function(records) {
                        bundle["preliminaryEstimateValues"] = records;
                        deferred.resolve(bundle);
                    }
                });
            return deferred.promise;
        },  

        _loadReleases : function(bundle) {
            var that = this;
            console.log("_loadReleases");
            var deferred = Ext.create('Deft.Deferred');
            that._loadAStoreWithAPromise( 
                'Release',
                true,
                [],
                {
                    projectScopeDown : false
                },
                "ReleaseDate").then({
                    success : function(records) {
                        bundle["releases"] = records;
                        deferred.resolve(bundle);
                    }
                });
            return deferred.promise;
        },  

        _loadIterations : function(bundle) {
            var that = this;
            console.log("_loadIterations");
            var deferred = Ext.create('Deft.Deferred');
            that._loadAStoreWithAPromise( 
                'Iteration',
                true,
                [],
                {
                    projectScopeDown : false
                },
                "IterationEndDate").then({
                    success : function(records) {
                        bundle["iterations"] = records;
                        deferred.resolve(bundle);
                    }
                });
            return deferred.promise;
        },  

        _loadProjectReleases : function(bundle) {
            console.log("_loadProjectReleases");
            var that = this;
            var deferred = Ext.create('Deft.Deferred');
            that._loadProjects(bundle).then({
                success: function(bundle) {
                    // read releases for each project returned.
                    Deft.Promise.map( bundle.projects,function(project) {
                    // Deft.Chain.sequence( bundle.projects,function(project) {
                        var deferred = Ext.create('Deft.Deferred');
                        // model_name, model_fields, filters,ctx,order
                        self._loadAStoreWithAPromise('Release',
                            true,
                            [{property:"ReleaseDate",operator:">",value:self.getLastYearDate()},
                             {property:"ReleaseStartDate",operator:"<=",value:self.getToday()}
                            ],
                            {
                                project : project.get("_ref"),
                                projectScopeDown : true
                            }
                        ).then({
                            success: function(records) {
                                deferred.resolve(records);
                            }
                        })
                        return deferred.promise;
                    }).then({
                        success : function(projectReleases) {
                            var prs = _.map(bundle.projects,function(project,i){
                                // console.log("context",self.ctx.getProject(),project.get("ObjectID"));
                                return {
                                    project : project,
                                    parent : self.ctx.getProject().ObjectID == project.get("ObjectID"),
                                    releases : self._groupReleases(projectReleases[i])
                                };
                            });
                            prs = _.sortBy( prs,function(pr) {
                                return pr.project.get("Name");
                            })
                            bundle.projectReleases = _.sortBy( prs,function(pr) {
                                return !(pr.parent);
                            })
                            deferred.resolve(bundle);
                        }
                    })
                }
            })
            return deferred.promise;

        },

        _groupReleases : function(releases) {
            // groups the set of release objects by name, sorts by release date
            // a logical release is the release name, dates and set of release objects.
            var groupedReleases = _.groupBy(releases,function(release) {
                return release.get("Name");
            });

            var logicalReleases = _.map( _.keys(groupedReleases), function(key) {
                var releases = groupedReleases[key];
                return {
                    name : _.first(releases).get("Name"),
                    releaseDate : _.first(releases).get("ReleaseDate"),
                    releaseStartDate : _.first(releases).get("ReleaseStartDate"),
                    releases : releases
                }              
            });
            return _.sortBy(logicalReleases,function(r){
                return r.releaseDate;
            })
        },

        _loadProjects : function(bundle) {
            // reads the set of immediate child projects from the ctx project
            var that = this;
            var deferred = Ext.create('Deft.Deferred');
            var fetch = ["ObjectID","Name","_ref","Parent","State","Parent","Children"];
            console.log("_loadProjects");
            self._loadAStoreWithAPromise('Project', 
                fetch, 
                [
                    {property : "ObjectID" , operator : "=", value : self.ctx.getProject().ObjectID }
                ]).then({
                    scope: that,
                    success: function(projects) {
                        if ( _.first(projects).get('Children').Count === 0 ) {
                            bundle.projects = projects;
                            deferred.resolve(bundle);
                        } else {
                            _.first(projects).getCollection('Children').load({
                                fetch : fetch,
                                callback: function(records, operation, success) {
                                    bundle.projects = _.filter(records,function(r) { return r.get("State")!=="Closed"; });
                                    bundle.projects.unshift(_.first(projects));
                                    deferred.resolve(bundle);
                                }
                            });
                        }
                    }
            });
            return deferred.promise;
        },

        _loadPortfolioItemTypes : function(bundle) {
            console.log("_loadPortfolioItemTypes");
            var deferred = Ext.create('Deft.Deferred');

            self._loadAStoreWithAPromise( 
                'TypeDefinition',
                true,
                [
                    { 
                        property:"Ordinal", operator:"!=", value:-1
                    } 
                ]).then(
                {
                    success : function(records) {
                        bundle["piTypes"] = records;
                        deferred.resolve(bundle);
                    }
                })

            return deferred.promise;
        },

        readProjects : function(states) {

            var deferred = Ext.create('Deft.Deferred');
            var me = this;

            self._loadAStoreWithAPromise('Project', 
                ["_ref","Parent","Children"], 
                [
                    {property : "ObjectID" , operator : "=", value : self.ctx.getProject().ObjectID }
                ]).then({
                    scope: me,
                    success: function(projects) {
                        if ( _.first(projects).get('Children').Count === 0 ) {
                            self.projects = projects;
                            deferred.resolve(self.projects);
                        } else {
                            _.first(projects).getCollection('Children').load({
                                fetch : ["ObjectID","Name","_ref","Parent","State"],
                                callback: function(records, operation, success) {
                                    self.projects = _.filter(records,function(r) { return r.get("State")!=="Closed"; });
                                    self.projects.push(_.first(projects));
                                    console.log("self.projects",self.projects,projects);
                                    deferred.resolve(self.projects);
                                }
                            });
                        }
                    }
            });
            return deferred.promise;
        },    

        readStories : function(projects) {
            console.log('readStories', projects, self.filter);
            var me = this;

            var promises = _.map(projects,function(project) {
                var deferred = Ext.create('Deft.Deferred');
                self._loadAStoreWithAPromise(
                    'HierarchicalRequirement', 
                    ["ObjectID","ScheduleState","PlanEstimate","Project"], 
                    [self.filter],
                    {   project: project.get("_ref"),
                        projectScopeUp: false,
                        projectScopeDown: true
                    }).then({
                    scope: me,
                    success: function(stories) {
                        console.log('stories',stories);
                        deferred.resolve(stories);
                    }
                });
                return deferred.promise;
            });

            return Deft.Promise.all(promises);

        },

        readFeatures : function(projects) {

            var me = this;

            var readFeatureType = function() {
                var deferred = Ext.create('Deft.Deferred');
                self._loadAStoreWithAPromise(
                    'TypeDefinition', 
                    ["TypePath"], 
                    [ { property:"Ordinal", operator:"=", value:0} ]
                    ).then({
                    scope: me,
                    success: function(types) {
                        deferred.resolve(_.first(types).get("TypePath"));
                    }
                });
                return deferred.promise;
            };

            var readFeatures = function(type) {

                var promises = _.map(projects,function(project) {
                    var deferred = Ext.create('Deft.Deferred');
                    self._loadAStoreWithAPromise(
                        type, 
                        ["FormattedID","Name","ObjectID","LeafStoryCount","LeafStoryPlanEstimateTotal",
                        "PreliminaryEstimate", "AcceptedLeafStoryCount", "AcceptedLeafStoryPlanEstimateTotal",
                        "PercentDoneByStoryCount","c_ValueMetricKPI","Rank","State"],
                        [self.featureFilter],
                        {   project: project.get("_ref"),
                            projectScopeUp: false,
                            projectScopeDown: true
                        },
                        [ { property : 'DragAndDropRank', direction : 'ASC' } ]).then({
                        scope: me,
                        success: function(stories) {
                            deferred.resolve(stories);
                        }
                    });
                    return deferred.promise;
                });

                return Deft.Promise.all(promises);
            };

            var deferred = Ext.create('Deft.Deferred');
            Deft.Chain.pipeline([readFeatureType,readFeatures],self).then({
                success: function(results) {
                    deferred.resolve(results);
                }
            });
            return deferred.promise;

        },

        readPreferenceValues : function(keys) {

            var me = this;

            var promises = _.map(keys,function(key) {
                var deferred = Ext.create('Deft.Deferred');
                self._loadAStoreWithAPromise(
                        "Preference", 
                        ["Name","Value"], 
                        [{ property : "Name", operator : "=", value : key }]
                    ).then({
                        scope: me,
                        success: function(values) {
                            deferred.resolve(values);
                        },
                        failure: function(error) {
                            deferred.resolve("");
                        }
                    });
                return deferred.promise;
            });
            return Deft.Promise.all(promises);
        },

        _loadAStoreWithAPromise: function(model_name, model_fields, filters,ctx,order){
            var deferred = Ext.create('Deft.Deferred');
            var me = this;
              
            var config = {
                model: model_name,
                fetch: model_fields,
                filters: filters,
                limit: 'Infinity'
            };
            if (!_.isUndefined(ctx)&&!_.isNull(ctx)) {
                config.context = ctx;
            }
            if (!_.isUndefined(order)&&!_.isNull(order)) {
                config.order = order;
            }

            Ext.create('Rally.data.wsapi.Store', config ).load({
                callback : function(records, operation, successful) {
                    if (successful){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                    }
                }
            });
            return deferred.promise;
        },

        getLastYearDate : function() {
            var date = new Date();
            date.setFullYear( date.getFullYear() - 1 );
            return Rally.util.DateTime.toIsoString(date, false);
        },
        getToday : function() {
            var date = new Date();
            return Rally.util.DateTime.toIsoString(date, false);
        },

        recurseObject : function( obj, callback ) {

        var deferred = Ext.create('Deft.Deferred');
        var list = [];
        var stack = 1;

            var childItems = function( obj, collection, callback ) {
                var children = obj.get(collection);

                if (children && children.Count > 0) {
                    stack = stack + children.Count;
                    obj.getCollection(collection).load({
                        fetch : true,
                        callback : function(records, operation, success) {
                            callback(records);
                        }
                    });
                }
            };

            var walk = function(root) {
                console.log(root.get("FormattedID"),stack);
                list.push(root); stack = stack - 1;

                _.each(["Children","UserStories","Tasks","Defects","TestCases"],function(collection){ 
                    childItems(root,collection, function(records){
                        _.each(records,function(record) {
                            walk(record);
                        })
                    });
                })
                console.log(root.get("FormattedID"),stack);
                if (stack==0) {
                    deferred.resolve(list);
                }
            }

            walk(obj);

            return deferred.promise;
    }

    };
});
                /*global setTimeout: false, console: false */(function(){var a={},b=this,c=b.async;typeof module!="undefined"&&module.exports?module.exports=a:b.async=a,a.noConflict=function(){return b.async=c,a};var d=function(a,b){if(a.forEach)return a.forEach(b);for(var c=0;c<a.length;c+=1)b(a[c],c,a)},e=function(a,b){if(a.map)return a.map(b);var c=[];return d(a,function(a,d,e){c.push(b(a,d,e))}),c},f=function(a,b,c){return a.reduce?a.reduce(b,c):(d(a,function(a,d,e){c=b(c,a,d,e)}),c)},g=function(a){if(Object.keys)return Object.keys(a);var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(c);return b};typeof process=="undefined"||!process.nextTick?a.nextTick=function(a){setTimeout(a,0)}:a.nextTick=process.nextTick,a.forEach=function(a,b,c){c=c||function(){};if(!a.length)return c();var e=0;d(a,function(d){b(d,function(b){b?(c(b),c=function(){}):(e+=1,e===a.length&&c(null))})})},a.forEachSeries=function(a,b,c){c=c||function(){};if(!a.length)return c();var d=0,e=function(){b(a[d],function(b){b?(c(b),c=function(){}):(d+=1,d===a.length?c(null):e())})};e()},a.forEachLimit=function(a,b,c,d){d=d||function(){};if(!a.length||b<=0)return d();var e=0,f=0,g=0;(function h(){if(e===a.length)return d();while(g<b&&f<a.length)f+=1,g+=1,c(a[f-1],function(b){b?(d(b),d=function(){}):(e+=1,g-=1,e===a.length?d():h())})})()};var h=function(b){return function(){var c=Array.prototype.slice.call(arguments);return b.apply(null,[a.forEach].concat(c))}},i=function(b){return function(){var c=Array.prototype.slice.call(arguments);return b.apply(null,[a.forEachSeries].concat(c))}},j=function(a,b,c,d){var f=[];b=e(b,function(a,b){return{index:b,value:a}}),a(b,function(a,b){c(a.value,function(c,d){f[a.index]=d,b(c)})},function(a){d(a,f)})};a.map=h(j),a.mapSeries=i(j),a.reduce=function(b,c,d,e){a.forEachSeries(b,function(a,b){d(c,a,function(a,d){c=d,b(a)})},function(a){e(a,c)})},a.inject=a.reduce,a.foldl=a.reduce,a.reduceRight=function(b,c,d,f){var g=e(b,function(a){return a}).reverse();a.reduce(g,c,d,f)},a.foldr=a.reduceRight;var k=function(a,b,c,d){var f=[];b=e(b,function(a,b){return{index:b,value:a}}),a(b,function(a,b){c(a.value,function(c){c&&f.push(a),b()})},function(a){d(e(f.sort(function(a,b){return a.index-b.index}),function(a){return a.value}))})};a.filter=h(k),a.filterSeries=i(k),a.select=a.filter,a.selectSeries=a.filterSeries;var l=function(a,b,c,d){var f=[];b=e(b,function(a,b){return{index:b,value:a}}),a(b,function(a,b){c(a.value,function(c){c||f.push(a),b()})},function(a){d(e(f.sort(function(a,b){return a.index-b.index}),function(a){return a.value}))})};a.reject=h(l),a.rejectSeries=i(l);var m=function(a,b,c,d){a(b,function(a,b){c(a,function(c){c?(d(a),d=function(){}):b()})},function(a){d()})};a.detect=h(m),a.detectSeries=i(m),a.some=function(b,c,d){a.forEach(b,function(a,b){c(a,function(a){a&&(d(!0),d=function(){}),b()})},function(a){d(!1)})},a.any=a.some,a.every=function(b,c,d){a.forEach(b,function(a,b){c(a,function(a){a||(d(!1),d=function(){}),b()})},function(a){d(!0)})},a.all=a.every,a.sortBy=function(b,c,d){a.map(b,function(a,b){c(a,function(c,d){c?b(c):b(null,{value:a,criteria:d})})},function(a,b){if(a)return d(a);var c=function(a,b){var c=a.criteria,d=b.criteria;return c<d?-1:c>d?1:0};d(null,e(b.sort(c),function(a){return a.value}))})},a.auto=function(a,b){b=b||function(){};var c=g(a);if(!c.length)return b(null);var e={},h=[],i=function(a){h.unshift(a)},j=function(a){for(var b=0;b<h.length;b+=1)if(h[b]===a){h.splice(b,1);return}},k=function(){d(h.slice(0),function(a){a()})};i(function(){g(e).length===c.length&&(b(null,e),b=function(){})}),d(c,function(c){var d=a[c]instanceof Function?[a[c]]:a[c],g=function(a){if(a)b(a),b=function(){};else{var d=Array.prototype.slice.call(arguments,1);d.length<=1&&(d=d[0]),e[c]=d,k()}},h=d.slice(0,Math.abs(d.length-1))||[],l=function(){return f(h,function(a,b){return a&&e.hasOwnProperty(b)},!0)&&!e.hasOwnProperty(c)};if(l())d[d.length-1](g,e);else{var m=function(){l()&&(j(m),d[d.length-1](g,e))};i(m)}})},a.waterfall=function(b,c){c=c||function(){};if(!b.length)return c();var d=function(b){return function(e){if(e)c(e),c=function(){};else{var f=Array.prototype.slice.call(arguments,1),g=b.next();g?f.push(d(g)):f.push(c),a.nextTick(function(){b.apply(null,f)})}}};d(a.iterator(b))()},a.parallel=function(b,c){c=c||function(){};if(b.constructor===Array)a.map(b,function(a,b){a&&a(function(a){var c=Array.prototype.slice.call(arguments,1);c.length<=1&&(c=c[0]),b.call(null,a,c)})},c);else{var d={};a.forEach(g(b),function(a,c){b[a](function(b){var e=Array.prototype.slice.call(arguments,1);e.length<=1&&(e=e[0]),d[a]=e,c(b)})},function(a){c(a,d)})}},a.series=function(b,c){c=c||function(){};if(b.constructor===Array)a.mapSeries(b,function(a,b){a&&a(function(a){var c=Array.prototype.slice.call(arguments,1);c.length<=1&&(c=c[0]),b.call(null,a,c)})},c);else{var d={};a.forEachSeries(g(b),function(a,c){b[a](function(b){var e=Array.prototype.slice.call(arguments,1);e.length<=1&&(e=e[0]),d[a]=e,c(b)})},function(a){c(a,d)})}},a.iterator=function(a){var b=function(c){var d=function(){return a.length&&a[c].apply(null,arguments),d.next()};return d.next=function(){return c<a.length-1?b(c+1):null},d};return b(0)},a.apply=function(a){var b=Array.prototype.slice.call(arguments,1);return function(){return a.apply(null,b.concat(Array.prototype.slice.call(arguments)))}};var n=function(a,b,c,d){var e=[];a(b,function(a,b){c(a,function(a,c){e=e.concat(c||[]),b(a)})},function(a){d(a,e)})};a.concat=h(n),a.concatSeries=i(n),a.whilst=function(b,c,d){b()?c(function(e){if(e)return d(e);a.whilst(b,c,d)}):d()},a.until=function(b,c,d){b()?d():c(function(e){if(e)return d(e);a.until(b,c,d)})},a.queue=function(b,c){var e=0,f={tasks:[],concurrency:c,saturated:null,empty:null,drain:null,push:function(b,e){b.constructor!==Array&&(b=[b]),d(b,function(b){f.tasks.push({data:b,callback:typeof e=="function"?e:null}),f.saturated&&f.tasks.length==c&&f.saturated(),a.nextTick(f.process)})},process:function(){if(e<f.concurrency&&f.tasks.length){var a=f.tasks.shift();f.empty&&f.tasks.length==0&&f.empty(),e+=1,b(a.data,function(){e-=1,a.callback&&a.callback.apply(a,arguments),f.drain&&f.tasks.length+e==0&&f.drain(),f.process()})}},length:function(){return f.tasks.length},running:function(){return e}};return f};var o=function(a){return function(b){var c=Array.prototype.slice.call(arguments,1);b.apply(null,c.concat([function(b){var c=Array.prototype.slice.call(arguments,1);typeof console!="undefined"&&(b?console.error&&console.error(b):console[a]&&d(c,function(b){console[a](b)}))}]))}};a.log=o("log"),a.dir=o("dir"),a.memoize=function(a,b){var c={},d={};b=b||function(a){return a};var e=function(){var e=Array.prototype.slice.call(arguments),f=e.pop(),g=b.apply(null,e);g in c?f.apply(null,c[g]):g in d?d[g].push(f):(d[g]=[f],a.apply(null,e.concat([function(){c[g]=arguments;var a=d[g];delete d[g];for(var b=0,e=a.length;b<e;b++)a[b].apply(null,arguments)}])))};return e.unmemoized=a,e},a.unmemoize=function(a){return function(){return(a.unmemoized||a).apply(null,arguments)}}})();

            Rally.launchApp('CustomApp', {
                name:"snapshots-per-month",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
     /* Add app styles here */
}

    </style>
</head>
<body></body>
</html>
